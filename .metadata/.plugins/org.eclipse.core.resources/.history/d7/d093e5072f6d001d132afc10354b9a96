#include "LCD_HXD8357D.h"
#include "stm32l4xx_hal.h"

// Probably going to move these to a different file, but for now
void uint16_to_bytes(uint16_t in, uint8_t *out)
{
	out[0] = (in >> 8) & 0xFF;
	out[1] = in & 0xFF;
}

void int16_to_bytes(int16_t in, uint8_t *out)
{
	out[0] = (in >> 8) & 0xFF;
	out[1] = in & 0xFF;
}

void uint32_to_bytes(uint32_t in, uint8_t *out)
{
	out[0] = (in >> 24) & 0xFF;
	out[1] = (in >> 16) & 0xFF;
	out[2] = (in >> 8) & 0xFF;
	out[3] = in & 0xFF;
}

void int32_to_bytes(int32_t in, uint8_t *out)
{
	out[0] = (in >> 24) & 0xFF;
	out[1] = (in >> 16) & 0xFF;
	out[2] = (in >> 8) & 0xFF;
	out[3] = in & 0xFF;
}


static const uint8_t init[] = {
    HX8357_SWRESET, 0x80 + 10/5, // Soft reset, then delay 10 ms
    HX8357D_SETC, 3,
      0xFF, 0x83, 0x57,
    0xFF, 0x80 + 300/5,          // No command, just delay 300 ms
    HX8357_SETRGB, 4,
      0x80, 0x00, 0x06, 0x06,    // 0x80 enables SDO pin (0x00 disables)
    HX8357D_SETCOM, 1,
      0x25,                      // -1.52V
    HX8357_SETOSC, 1,
      0x68,                      // Normal mode 70Hz, Idle mode 55 Hz
    HX8357_SETPANEL, 1,
      0x05,                      // BGR, Gate direction swapped
    HX8357_SETPWR1, 6,
      0x00,                      // Not deep standby
      0x15,                      // BT
      0x1C,                      // VSPR
      0x1C,                      // VSNR
      0x83,                      // AP
      0xAA,                      // FS
    HX8357D_SETSTBA, 6,
      0x50,                      // OPON normal
      0x50,                      // OPON idle
      0x01,                      // STBA
      0x3C,                      // STBA
      0x1E,                      // STBA
      0x08,                      // GEN
    HX8357D_SETCYC, 7,
      0x02,                      // NW 0x02
      0x40,                      // RTN
      0x00,                      // DIV
      0x2A,                      // DUM
      0x2A,                      // DUM
      0x0D,                      // GDON
      0x78,                      // GDOFF
    HX8357D_SETGAMMA, 34,
      0x02, 0x0A, 0x11, 0x1d, 0x23, 0x35, 0x41, 0x4b, 0x4b,
      0x42, 0x3A, 0x27, 0x1B, 0x08, 0x09, 0x03, 0x02, 0x0A,
      0x11, 0x1d, 0x23, 0x35, 0x41, 0x4b, 0x4b, 0x42, 0x3A,
      0x27, 0x1B, 0x08, 0x09, 0x03, 0x00, 0x01,
    HX8357_COLMOD, 1,
      0x55,                      // 16 bit
    HX8357_MADCTL, 1,
      0xC0,
    HX8357_TEON, 1,
      0x00,                      // TW off
    HX8357_TEARLINE, 2,
      0x00, 0x02,
    HX8357_SLPOUT, 0x80 + 150/5, // Exit Sleep, then delay 150 ms
    HX8357_DISPON, 0x80 +  50/5, // Main screen turn on, delay 50 ms
    0                            // END OF COMMAND LIST
  };

void LCD_reset()
{
	HAL_GPIO_WritePin(RST_PIN, RST_PIN_NUMBER, GPIO_PIN_SET);
	HAL_Delay(100);
	HAL_GPIO_WritePin(RST_PIN, RST_PIN_NUMBER, GPIO_PIN_RESET);
	HAL_Delay(100);
	HAL_GPIO_WritePin(RST_PIN, RST_PIN_NUMBER, GPIO_PIN_SET);
	HAL_Delay(200);
}

HAL_StatusTypeDef LCD_writeCommand(SPI_HandleTypeDef spi, uint8_t cmd)
{
	HAL_StatusTypeDef result;
	HAL_GPIO_WritePin(DC_PIN, DC_PIN_NUMBER, GPIO_PIN_RESET);
	result = HAL_SPI_Transmit(spi, &cmd, 1, 0);
	HAL_GPIO_WritePin(DC_PIN, DC_PIN_NUMBER, GPIO_PIN_SET);
	return result;
}

void LCD_startWrite()
{
	HAL_GPIO_WritePin(CS_PIN, CS_PIN_NUMBER, GPIO_PIN_RESET);
}

void LCD_endWrite()
{
	HAL_GPIO_WritePin(CS_PIN, CS_PIN_NUMBER, GPIO_PIN_SET);
}

int LCD_begin(SPI_HandleTypeDef spi)
{
	LCD_reset();
	LCD_startWrite();
	const uint8_t *addr = init;
	uint8_t cmd, x, numArgs;
	HAL_StatusTypeDef result;
	while((cmd = &(addr++)) > 0) // '0' command ends list
	{
		if (cmd != 0xFF) // '255' is ignored
		{
			result = LCD_writeCommand(cmd);
			if (result != HAL_OK) return 0;
		}
		x = &(addr++);
		numArgs = x & 0x7F;
		if (x & 0x80) // If high bit set...
		{
			HAL_Delay(numArgs * 5); // numArgs is actually a delay time (5ms units)
		}
		else // Otherwise, issue args to command...
		{
			while (numArgs--)
			{
				result = HAL_SPI_Transmit(spi, &(addr++), 1, 0);
				if (result != HAL_OK) return 0;
			}
		}
	}
	LCD_endWrite();
	return 1;
}

int invertDisplay(SPI_HandleTypeDef spi, int invert)
{
	LCD_startWrite();
	int result = LCD_writeCommand(spi, invert ? HX8357_INVON : HX8357_INVOFF);
	LCD_endWrite();
	return result;
}

int LCD_setAddrWindow(SPI_HandleTypeDef spi, uint16_t x1, uint16_t y1, uint16_t w, uint16_t h)
{
	uint16_t x2 = (x1 + w - 1), y2 = (y1 + h - 1);
	uint8_t bytes[4][2];
	convert_u16_to_bytes(x1, &bytes[0][0]);
	convert_u16_to_bytes(x2, &bytes[1][0]);
	convert_u16_to_bytes(y1, &bytes[2][0]);
	convert_u16_to_bytes(y2, &bytes[3][0]);

	LCD_startWrite();
	LCD_writeCommand(HX8357_CASET); // Column address set
	HAL_SPI_Transmit(spi, &bytes[0][0], 2, 0);
	HAL_SPI_Transmit(spi, &bytes[0][1], 2, 0);
	LCD_writeCommand(HX8357_PASET); // Row address set
	HAL_SPI_Transmit(spi, &bytes[0][2], 2, 0);
	HAL_SPI_Transmit(spi, &bytes[0][3], 2, 0);
	LCD_writeCommand(HX8357_RAMWR); // Write to RAM
	LCD_endWrite();
}

uint16_t LCD_color565(uint8_t red, uint8_t green, uint8_t blue) {
    return ((red & 0xF8) << 8) | ((green & 0xFC) << 3) | ((blue & 0xF8) >> 3);
}

void LCD_pushColor(SPI_HandleTypeDef spi, uint16_t color) {
  uint8_t bytes[2];
  uint16_to_bytes(color, &bytes[0]);
  LCD_startWrite();
  HAL_SPI_Transmit(spi, &bytes[0], 2, 0);
  LCD_endWrite();
}

void LCD_writePixel(SPI_HandleTypeDef spi, int16_t x, int16_t y, uint16_t color) {
    if ((x < 0) ||(x >= HX8357_TFTWIDTH) || (y < 0) || (y >= HX8357_TFTHEIGHT)) return;
    LCD_setAddrWindow(spi, x, y, 1, 1);
    LCD_pushColor(spi, color);
}
